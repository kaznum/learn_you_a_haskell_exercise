import Control.Monad
-- *Main> let f = (+1) . (*100)
-- *Main> f 4
-- 401

-- *Main> let g = (\x -> return (x+1)) <=< (\x -> return (x*100)) :: Int -> Maybe Int
-- *Main> Just 4 >>= g
-- Just 401

-- *Main> Just 4 >>= (\x -> return (x+1)) >>= (\x -> return (x*100))
-- Just 500

-- *Main> let f = foldr (.) id [(+1), (*100), (+1)]
-- *Main> f 1
-- 201

-- *Main> let p = foldr (.) id [(+1), (*100), (+2)]
-- *Main> p 1
-- 301

type KnightPos = (Int, Int)

moveKnight :: KnightPos -> [KnightPos]
moveKnight (c,r) = filter onBoard
                   [(c+2,r-1),(c+2,r+1),(c-2,r-1),(c-2,r+1)
                   ,(c+1,r-2),(c+1,r+2),(c-1,r-2),(c-1,r+2)
                   ]
  where onBoard (c,r) = c `elem` [1..8] && r `elem` [1..8]

in3 start = return start >>= moveKnight >>= moveKnight >>= moveKnight

canReachIn3 :: KnightPos -> KnightPos -> Bool
canReachIn3 start end = end `elem` in3 start

-- *Main> moveKnight (2,3)
-- [(4,2),(4,4),(3,1),(3,5),(1,1),(1,5)]
-- *Main> in3 (2,3)
-- [(8,2),(4,2),(7,3),(5,3),(8,2),(8,4),(4,2),(4,4),(7,1),(7,5),(5,1),(5,5),(4,2),(3,3),(1,3),(4,2),(4,4),(3,1),(3,5),(1,1),(1,5),(7,3),(7,5),(3,3),(3,5),(6,2),(6,6),(4,2),(4,6),(5,3),(5,5),(1,3),(1,5),(4,2),(4,6),(2,2),(2,6),(8,2),(8,4),(4,2),(4,4),(7,1),(7,5),(5,1),(5,5),(8,4),(8,6),(4,4),(4,6),(7,3),(7,7),(5,3),(5,7),(4,2),(4,4),(3,1),(3,5),(1,1),(1,5),(4,4),(4,6),(3,3),(3,7),(1,3),(1,7),(7,1),(7,3),(3,1),(3,3),(6,4),(4,4),(7,5),(7,7),(3,5),(3,7),(6,4),(6,8),(4,4),(4,8),(5,1),(5,3),(1,1),(1,3),(4,4),(2,4),(5,5),(5,7),(1,5),(1,7),(4,4),(4,8),(2,4),(2,8),(7,1),(7,3),(3,1),(3,3),(6,4),(4,4),(3,1),(3,3),(2,4),(6,2),(6,4),(2,2),(2,4),(5,1),(5,5),(3,1),(3,5),(4,2),(4,4),(3,1),(3,5),(1,1),(1,5),(7,3),(7,5),(3,3),(3,5),(6,2),(6,6),(4,2),(4,6),(7,5),(7,7),(3,5),(3,7),(6,4),(6,8),(4,4),(4,8),(3,3),(3,5),(2,2),(2,6),(3,5),(3,7),(2,4),(2,8),(6,2),(6,4),(2,2),(2,4),(5,1),(5,5),(3,1),(3,5),(6,6),(6,8),(2,6),(2,8),(5,5),(3,5),(4,2),(4,4),(3,1),(3,5),(1,1),(1,5),(4,6),(4,8),(3,5),(1,5),(5,1),(5,3),(1,1),(1,3),(4,4),(2,4),(4,2),(4,4),(3,1),(3,5),(1,1),(1,5),(5,3),(5,5),(1,3),(1,5),(4,2),(4,6),(2,2),(2,6),(5,5),(5,7),(1,5),(1,7),(4,4),(4,8),(2,4),(2,8),(4,2),(4,4),(3,1),(3,5),(1,1),(1,5),(4,6),(4,8),(3,5),(1,5)]
-- *Main> canReachIn3 (2,3) (4,4)
-- True
-- *Main> canReachIn3 (2,3) (4,5)
-- False

inMany :: Int -> KnightPos -> [KnightPos]
inMany x start = return start >>= foldr (<=<) return (replicate x moveKnight)

-- *Main> inMany 3 (2,3)
-- [(8,2),(4,2),(7,3),(5,3),(8,2),(8,4),(4,2),(4,4),(7,1),(7,5),(5,1),(5,5),(4,2),(3,3),(1,3),(4,2),(4,4),(3,1),(3,5),(1,1),(1,5),(7,3),(7,5),(3,3),(3,5),(6,2),(6,6),(4,2),(4,6),(5,3),(5,5),(1,3),(1,5),(4,2),(4,6),(2,2),(2,6),(8,2),(8,4),(4,2),(4,4),(7,1),(7,5),(5,1),(5,5),(8,4),(8,6),(4,4),(4,6),(7,3),(7,7),(5,3),(5,7),(4,2),(4,4),(3,1),(3,5),(1,1),(1,5),(4,4),(4,6),(3,3),(3,7),(1,3),(1,7),(7,1),(7,3),(3,1),(3,3),(6,4),(4,4),(7,5),(7,7),(3,5),(3,7),(6,4),(6,8),(4,4),(4,8),(5,1),(5,3),(1,1),(1,3),(4,4),(2,4),(5,5),(5,7),(1,5),(1,7),(4,4),(4,8),(2,4),(2,8),(7,1),(7,3),(3,1),(3,3),(6,4),(4,4),(3,1),(3,3),(2,4),(6,2),(6,4),(2,2),(2,4),(5,1),(5,5),(3,1),(3,5),(4,2),(4,4),(3,1),(3,5),(1,1),(1,5),(7,3),(7,5),(3,3),(3,5),(6,2),(6,6),(4,2),(4,6),(7,5),(7,7),(3,5),(3,7),(6,4),(6,8),(4,4),(4,8),(3,3),(3,5),(2,2),(2,6),(3,5),(3,7),(2,4),(2,8),(6,2),(6,4),(2,2),(2,4),(5,1),(5,5),(3,1),(3,5),(6,6),(6,8),(2,6),(2,8),(5,5),(3,5),(4,2),(4,4),(3,1),(3,5),(1,1),(1,5),(4,6),(4,8),(3,5),(1,5),(5,1),(5,3),(1,1),(1,3),(4,4),(2,4),(4,2),(4,4),(3,1),(3,5),(1,1),(1,5),(5,3),(5,5),(1,3),(1,5),(4,2),(4,6),(2,2),(2,6),(5,5),(5,7),(1,5),(1,7),(4,4),(4,8),(2,4),(2,8),(4,2),(4,4),(3,1),(3,5),(1,1),(1,5),(4,6),(4,8),(3,5),(1,5)]

canReachIn :: Int -> KnightPos -> KnightPos -> Bool
canReachIn x start end = end `elem` inMany x start

-- *Main> canReachIn 3 (2,3) (4,4)
-- True
-- *Main> canReachIn 3 (2,3) (4,5)
-- False

